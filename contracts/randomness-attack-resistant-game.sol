// SPDX-License-Identifier: SEE LICENSE IN LICENSE
pragma solidity ^0.8.9;

import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";

/** Implements chain link VRF  */
contract RandmonessAttackResistantGame is VRFConsumerBase {
    //Chainlink variables
    //The amount of LINK to send with the request
    uint public fee;

    //ID of public key against which randomness is generated
    bytes32 public keyHash;

    uint private _guessedNumber;

    bool private _lock;
    modifier notPlaying {
        require(!_lock, "Its already being played");
        _;
    }
    constructor(
        address vrfCoordinator,
        address linkToken,
        bytes32 vrfKeyHash,
        uint vrfFee
    ) payable VRFConsumerBase(vrfCoordinator, linkToken) {
        keyHash = vrfKeyHash;
        fee = vrfFee;
    }

    /**
     * Randomly picks a number out of 0 to 2^256 - 1
     */
    function pickACard() private view returns (uint) {
        // uses chainlink VRF
        uint pickedCard = uint(
            keccak256(
                abi.encodePacked(blockhash(block.number), block.timestamp)
            )
        );
        return pickedCard;
    }

    /**
     *fulfillRandomness is called by VRFCoordinator when it receives a valid VRF proof.
     *This function is overrided to act upon the random number generated by Chainlink VRF
     *@param requestId this ID is unique for the request we sent to VRF Coordinator
     *@param randomness this is the random uint256 generated and returned by VRF Coordinator
     */
    function fulfillRandomness(bytes32 requestId, uint randomness)
        internal
        virtual
        override
    {
        if (_guessedNumber == randomness) {
            (bool sent, ) = msg.sender.call{value: 0.1 ether}("");
            require(sent, "Failed to send ether");
        }

        // reset the game for next play
        _lock = false;
        _guessedNumber = 0;
    }

    function requestRandomness() private returns (bytes32 requestId) {
        //LINK is an internal interface for LINK token found within the VRFConsumerBase
        //Here we use the balanceOf method from the interface to make sure the our
        //contract has enough link so that we can request the VRFCoordinator for randomness
        require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK");

        //Make a request to the VRF coordinator
        //requestRandomness is a function within the VRFConsumerBase
        //it starts the process of randomness generation
        return requestRandomness(keyHash, fee);
    }

    /**
          It begins the game by first choosing a random number by calling `pickACard`
          It then verifies if the random number selected is equal to `_guess` passed by the player
          If the player guessed the correct number, it sends the player `0.1 ether`
      */
    function guess(uint _guess) public notPlaying {
        _guessedNumber = _guess;
        requestRandomness();
    }

    /**
          Returns the balance of ether in the contract
      */
    function getBalance() public view returns (uint) {
        return address(this).balance;
    }
}
